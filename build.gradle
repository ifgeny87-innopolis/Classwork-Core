apply plugin: "java"
apply plugin: "war"

repositories {
    mavenCentral()
}

dependencies {
    // logging
    compile 'org.slf4j:slf4j-api:1.7.21'
//    compile 'org.slf4j:slf4j-simple:1.7.21'
    compile 'org.slf4j:slf4j-log4j12:1.7.21'
    compile 'log4j:log4j:1.2.17'

    // testing
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-all:1.9.5'

    // servlet and web development
    compile 'javax.servlet:javax.servlet-api:3.1.0'
    compile 'org.json:json:20160810'

    // mysql database driver
    compile 'mysql:mysql-connector-java:6.0.5'

    // Apache DBCP
    compile 'org.apache.commons:commons-dbcp2:2.1'

    // hibernate framework
    compile 'org.hibernate:hibernate-core:5.1.0.Final'
    compile 'org.hibernate:hibernate-entitymanager:5.1.0.Final'

    // hibernate library dependency
    compile 'dom4j:dom4j:1.4.1'

    // liquibase
    compile 'org.liquibase:liquibase-maven-plugin:3.5.3'

    // Spring 
    compile 'org.springframework:spring-core:4.3.5.RELEASE'
    compile 'org.springframework:spring-context:4.3.5.RELEASE'
    compile 'org.springframework:spring-web:4.3.5.RELEASE'
    compile 'org.springframework:spring-webmvc:4.3.5.RELEASE'
    compile 'org.springframework:spring-jdbc:4.3.5.RELEASE'
    compile 'org.springframework:spring-orm:4.3.5.RELEASE'

    // JSP Standard Tag Library
    compile 'jstl:jstl:1.2'

    // Jackson JSON mapper
    // Для Spring MVC: авто-конвертация Object в Json для контроллеров
    compile 'com.fasterxml.jackson.core:jackson-databind:2.4.3'
    compile 'com.fasterxml.jackson.core:jackson-core:2.4.3'
    compile 'com.fasterxml.jackson.jaxrs:jackson-jaxrs-base:2.6.1'
    compile 'org.codehaus.jackson:jackson-mapper-asl:1.9.13'

    // Spring Security
    compile 'org.springframework.security:spring-security-web:4.2.1.RELEASE'
    compile 'org.springframework.security:spring-security-config:4.2.1.RELEASE'
    compile 'org.springframework.security:spring-security-taglibs:4.2.1.RELEASE'
    compile 'org.springframework.security:spring-security-core:4.2.1.RELEASE'

    // Spring Data
    compile 'org.springframework.data:spring-data-commons:1.12.5.RELEASE'
    compile 'org.springframework.data:spring-data-jpa:1.10.6.RELEASE'
    compile 'org.springframework:spring-aspects:4.3.3.RELEASE'
    compile 'org.springframework:spring-framework-bom:4.1.3.RELEASE'
}

compileJava {
    options.encoding = "UTF-8"
}

jar {
    // буду сразу подсовывать манифест
    /*manifest {
        attributes(
                "Main-Class": "tests.RRR",
                "Class-Path": configurations.compile.collect { it.getName() }.join(" ")
        )
    }*/

    /**
     * Дальше тема такая:
     *  1. Ищем файл build.num, в нем должны быть две строки "номер версии" и "дата последнего билда"
     *  2. Если файла нет, создается с нуля
     *  3. В файле changelog.txt помещается информация о новом билде и список измененных файлов
     */
    File buildNumFile = file("build.num")
    String buildVersion = "0.0.1"  // default
    long lastModified = 0       // default

    if (buildNumFile.exists()) {
        String[] lines = buildNumFile.readLines()
        assert lines.size() == 2, 'File `build.num` must have two lines'

        // дата создания последнего билда
        lastModified = Long.parseLong(lines[1])

        // получаю номер билда из файла
        lines = lines[0].split("\\.")
        assert lines.length == 3, 'Build version wrong'
        lines[2] = Integer.parseInt(lines[2]) + 1 + ""
        buildVersion = String.join(".", lines)
    }

    // устанавливаю версию для имени пакета
    jar.setAppendix(buildVersion)

    // открываю changelog.txt и пишу в него список обновленных файлов
    File changelog = file("changelog.txt")
    if (changelog.size())
    // добавлю <hr/>
        changelog << "\n" + String.format("%60s", "").replace(" ", "-") + "\n"

    changelog << "New version " + getVersion() + " build " + buildVersion + "\n"
    changelog << "Date: " + new Date() + "\n"
    changelog << "Change files from: " + new Date(lastModified) + "\n"

    FileTree tree = fileTree(dir: "src")
    // буду также отрезать кусок от имени файла, ибо где лежит src и так понятно
    int pathLength = tree.getDir().getAbsolutePath().length() + 1
    tree
            .matching { include "main/**", "test/**" } // просто пример инклуда
            .filter { f -> return f.lastModified() > lastModified } // фильтр по дате изменения
            .each { f -> changelog << "- " + f.getPath().substring(pathLength) + "\n" }

    // сохраняю новый номер билда и текущее время билда, файл надо сначала затереть
    buildNumFile.delete()
    buildNumFile << buildVersion + "\n"
    buildNumFile << new Date().getTime()
}